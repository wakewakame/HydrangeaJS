<!DOCTYPE html>
<html>
<head>
	<!-- Select Text Encode -->
	<meta content="ja" http-equiv="Content-Language" />
	<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
	<!-- Set Resolution -->
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<!-- full screen on iOS browser -->
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<!-- title -->
	<title>NodeShader</title>

	<script type="text/javascript" src="../dst/hydrangea.js"></script>
	<script src="https://pagecdn.io/lib/ace/1.4.5/ace.js" integrity="sha256-5Xkhn3k/1rbXB+Q/DX/2RuAtaB4dRRyQvMs83prFjpM=" crossorigin="anonymous"></script>
	<script type="text/javascript">
		const Page = HydrangeaJS.GUI.Page.Page;
		const PageEvent = HydrangeaJS.GUI.Page.PageEvent;
		const NodeCanvas = HydrangeaJS.GUI.Templates.NodeCanvas;
		const TimeNode = HydrangeaJS.Extra.ShaderNode.TimeNode;
		const PictureNode = HydrangeaJS.Extra.ShaderNode.PictureNode;
		const ShaderNode = HydrangeaJS.Extra.ShaderNode.ShaderNode;
		const FrameNode = HydrangeaJS.Extra.ShaderNode.FrameNode;

		const ConfigElement = class{
			constructor(nodeType = Node){
				this.nodeCanvasPage = null;
				this.element = null;
				this.nodeType = nodeType;
			}
			init() {}
			active(){}
			canAdapt(node){ return node instanceof this.nodeType; }
			addElement(name = "div", left = 0.0, top = 0.0, right = 1.0, bottom = 1.0, style = {}){
				style["display"] = "none";
				return this.nodeCanvasPage.page.addElement(name, left, top, right, bottom, style);
			}
		};

		const ShaderConfigElement = class extends ConfigElement{
			constructor(){
				super(ShaderNode);
			}
			init(){
				this.element = this.addElement("div", 0.0, 0.5, 1.0, 1.0, {
					"background": "#FFFFFF80"
				});
				this.element.id = "shader_editor";
				this.editor = ace.edit(this.element.id);
				this.editor.setTheme("ace/theme/tomorrow");
				this.editor.setOptions({
					fontSize: "14pt"
				});
				this.editor.getSession().setMode("ace/mode/glsl");
				this.editor.on("change", (e) => {
					const node = this.nodeCanvasPage.getActiveNode();
					if (node !== null && this.canAdapt(node)) {
						const code = this.editor.getValue();
						if (
							code !== "" &&
							code !== node.compileState.code
						) node.loadShader(code);
					}
				});
			}
			active(node){
				this.editor.setValue(node.compileState.code);
				this.editor.gotoLine(1, 0);
			}
		};

		const NodeCanvasPageEvent = class {
			constructor() {}
			init(nodeCanvasPage) {}
			loop(nodeCanvasPage) {}
			dropFiles(nodeCanvasPage, files) {}
		};

		const NodeCanvasPage = class extends NodeCanvas{
			constructor(nodeCanvasPageEvent = new NodeCanvasPageEvent()) {
				super();
				this.nodeCanvasPageEvent = nodeCanvasPageEvent;
				this.configElements = [];
				const TmpPageEvent = class extends PageEvent{
					constructor(nodeCanvasPage) {
						super();
						this.nodeCanvasPage = nodeCanvasPage;
					}
					init(page) {
						page.addComponent(this.nodeCanvasPage);
						this.nodeCanvasPage.nodeCanvasPageEvent.init(this.nodeCanvasPage);
					}
					loop(page) { this.nodeCanvasPage.nodeCanvasPageEvent.loop(this.nodeCanvasPage); }
					dropFiles(page, files) {
						this.nodeCanvasPage.nodeCanvasPageEvent.dropFiles(this.nodeCanvasPage, files);
					}
				};
				this.page = new Page(new TmpPageEvent(this));
			}
			addConfigElement(configElement){
				configElement.nodeCanvasPage = this;
				this.configElements.push(configElement);
				configElement.init();
			}
			mouseEvent(type, x, y, start_x, start_y){
				super.mouseEvent(type, x, y, start_x, start_y);
				if (type === "DOWN") {
					this.configElements.forEach(e => {
						e.element.style["display"] = "none";
					});
					const node = this.getActiveNode();
					if (node !== null && node.checkHit(x, y)) {
						this.configElements.filter(e => e.canAdapt(node)).forEach(e => {
							e.element.style["display"] = "inline";
							e.active(node);
						});
					}
				}
			}
			getActiveNode(){
				if (this.childs.length > 0) return this.childs[0];
				return null;
			}
		};

		const OriginalNodeCanvasPageEvent = class extends NodeCanvasPageEvent {
			constructor() {
				super();
			}
			init(nodeCanvasPage) {
				nodeCanvasPage.addConfigElement(new ShaderConfigElement());

				let node0 = nodeCanvasPage.add(new TimeNode(30 + 250 * 0, 300));
				let node1 = nodeCanvasPage.add(new PictureNode("lenna", "./lenna.png", 30 + 250 * 0, 30));
				let node2 = nodeCanvasPage.add(new ShaderNode  ("rotate", 30 + 250 * 1, 150, 500));
				let node3 = nodeCanvasPage.add(new FrameNode  ("result1", 30 + 250 * 2, 30, 512, 512));
				let node4 = nodeCanvasPage.add(new ShaderNode  ("colorful", 30 + 250 * 3, 150, 500));
				let node5 = nodeCanvasPage.add(new FrameNode  ("result2", 30 + 250 * 4, 30, 512, 512));

				node2.loadShader(
`precision highp float;
uniform sampler2D texture;
uniform vec2 texture_resolution;
uniform float time;
varying vec2 vUv;

void main(void){
	vec2 area = vec2(
		texture_resolution.x / exp2(ceil(log2(texture_resolution.x))),
		texture_resolution.y / exp2(ceil(log2(texture_resolution.y)))
	);
	vec2 p = vUv * area;
	p -= area * 0.5;
	p *= mat2(cos(time), -sin(time), sin(time), cos(time));
	p += area * 0.5;
	gl_FragColor = texture2D(texture, p);
}`
				);

				node4.loadShader(
`precision highp float;
uniform sampler2D texture;
uniform vec2 texture_resolution;
varying vec2 vUv;

void main(void){
	vec2 area = vec2(
		texture_resolution.x / exp2(ceil(log2(texture_resolution.x))),
		texture_resolution.y / exp2(ceil(log2(texture_resolution.y)))
	);
	vec2 p = vUv * area;
	gl_FragColor = texture2D(texture, p);
	gl_FragColor.rgb += vec3(p.x, 1.0 - sqrt(p.x * p.x + p.y * p.y), p.y);
}`
				);

				node2.inputs.childs[0].output = node1.outputs.childs[0];
				node2.inputs.childs[1].output = node1.outputs.childs[1];
				node2.inputs.childs[2].output = node0.outputs.childs[0];
				node3.inputs.childs[0].output = node2.outputs.childs[0];
				node4.inputs.childs[0].output = node3.outputs.childs[0];
				node4.inputs.childs[1].output = node3.outputs.childs[1];
				node5.inputs.childs[0].output = node4.outputs.childs[0];
			}
			loop(nodeCanvasPage) {
				nodeCanvasPage.resetAndJob();
			}
			dropFiles(page, files) { console.log(files); }
		};

		const nodeCanvasPage = new NodeCanvasPage(new OriginalNodeCanvasPageEvent());


	</script>
</head>
<body>
</body>
</html>
